# 242. 有效的字母异位词

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1:

```
输入: s = "anagram", t = "nagaram"
输出: true
```


示例 2:

```
输入: s = "rat", t = "car"
输出: false
说明:
你可以假设字符串只包含小写字母。
```

进阶:
如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？


## 思路

1. 暴力 sort sorted_str 相等？ O(nlogn)
2. hash map 统计每个字符的频次

解法一：

先排序 再比较

```go
func isAnagram(s string, t string) bool {

  if len(s) != len(t) {
    return false
  }

  sarr := make([]string, len(s))
  tarr := make([]string, len(t))
  
  for i:=0; i < len(s); i++ {
    sarr[i] = string(s[i])
    tarr[i] = string(t[i])
  }
  
  sort.Strings(sarr)
  sort.Strings(tarr)

  for i:=0; i < len(s); i++ {
    if sarr[i] != tarr[i] {
      return false
    }
  }
  return true
}
```

解法二：

利用 哈希表 统计词频

```go
func isAnagram(s string, t string) bool {

  if len(s) != len(t) {
    return false
  }
  
  smap := make(map[string]int)
  tmap := make(map[string]int)
  for i:=0; i < len(s); i++ {
    smap[string(s[i])] += 1 
    tmap[string(t[i])] += 1 
  }
 
  for k,v := range smap {
    if tmap[k] != v {
      return false
    }
  }
  return true
}
```

优化

```go
func isAnagram(s string, t string) bool {

  if len(s) != len(t) {
    return false
  }

  smap := make(map[int]int)
  tmap := make(map[int]int)
  for i:=0; i < len(s); i++ {
    smap[int(s[i] - 'a')] += 1 
    tmap[int(t[i] - 'a')] += 1 
  }

  for k,v := range smap {
    if tmap[k] != v {
      return false
    }
  }
  return true
}
```


解法三：

用 counter 遍历第一个字符串，记录字符出现次数。第二次遍历对应减少 counter 字符的值。  
如果减之前就为零，则说明不是异位词

```go
func isAnagram(s string, t string) bool {

  if len(s) != len(t) {
    return false
  }

  counter := make(map[int]int)
  for _, c := range s {
    counter[int(c - 'a')]++
  }

  for _, c:= range t {
    if counter[int(c - 'a')] == 0 {
      return false
    }
    counter[int(c - 'a')]--
  }

  return true
}
```

