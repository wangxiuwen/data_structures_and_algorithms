# Pow(x, n)

[题目来源](https://leetcode-cn.com/problems/powx-n)

实现 pow(x, n) ，即计算 x 的 n 次幂函数。

示例 1:

```
输入: 2.00000, 10
输出: 1024.00000
```

示例 2:

```
输入: 2.10000, 3
输出: 9.26100
```

示例 3:

```
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```

说明:

```
-100.0 < x < 100.0
n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。
```


# 思路

1. 暴力

```
result = 1
for i:0 -> n {
  result *=x
}
O(n)
```

leetcode 执行暴力法代码 `超出时间限制`

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
      if n < 0:
        x = 1 / x
        n = -n
      result = 1
      for i in range(1, n+1):
        result = result * x
      return result
```

2. 分治

templage 

>1. terminator   
>2. process(split your big problem)   
>3. drill down subproblems merge(sub result)  
>4. reverse states  


```
x^n ---> 2^10:  2^5 -> (2^2)*2
pow(x, n):
  subproblem: subresult = pow(x, n/2)

merge:
  if n % 2 == 1 {
    // odd
    result = subresult * subresult * x
  } else {
    result = subresult * subresult
  }

O(log(n))
```

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
      if n < 0:
        x = 1 / x
        n = -n
      return self.fastPow(x, n)

    def fastPow(self, x, n):
      if n == 0:
        return 1.0
      half = self.fastPow(x, n // 2)
      if n % 2 == 0:
        return half * half
      else:
        return half * half * x
```


3. 牛顿迭代法

