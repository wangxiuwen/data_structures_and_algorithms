# 242. 有效的字母异位词

[题目地址](https://leetcode-cn.com/problems/valid-anagram/)

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1:

```
输入: s = "anagram", t = "nagaram"
输出: true
```


示例 2:

```
输入: s = "rat", t = "car"
输出: false
说明:
你可以假设字符串只包含小写字母。
```

进阶:
如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？


## 思路

1. 暴力 sort sorted_str 相等？ O(nlogn)
2. hash map 统计每个字符的频次

## 解法一

先排序 再比较

排序用快排的话 是 O(NlogN)

```Java
class Solution {
    public boolean isAnagram(String s, String t) {
        
        if (s.length() != t.length()) return false;
        char[] s1 = s.toCharArray();
        char[] t1 = t.toCharArray();

        Arrays.sort(s1);
        Arrays.sort(t1);

        for (int i = 0; i < s1.length; i++) {
            if (s1[i] != t1[i]) return false;
        }
        return true;
    }
}
```

```go
func isAnagram(s string, t string) bool {

  if len(s) != len(t) {
    return false
  }

  sarr := make([]string, len(s))
  tarr := make([]string, len(t))
  
  for i:=0; i < len(s); i++ {
    sarr[i] = string(s[i])
    tarr[i] = string(t[i])
  }
  
  sort.Strings(sarr)
  sort.Strings(tarr)

  for i:=0; i < len(s); i++ {
    if sarr[i] != tarr[i] {
      return false
    }
  }
  return true
}
```

## 解法二

利用 哈希表 统计词频

```go
func isAnagram(s string, t string) bool {

  if len(s) != len(t) {
    return false
  }
  
  smap := make(map[string]int)
  tmap := make(map[string]int)
  for i:=0; i < len(s); i++ {
    smap[string(s[i])] += 1 
    tmap[string(t[i])] += 1 
  }
 
  for k,v := range smap {
    if tmap[k] != v {
      return false
    }
  }
  return true
}
```

优化

```go
func isAnagram(s string, t string) bool {

  if len(s) != len(t) {
    return false
  }

  smap := make(map[int]int)
  tmap := make(map[int]int)
  for i:=0; i < len(s); i++ {
    smap[int(s[i] - 'a')] += 1 
    tmap[int(t[i] - 'a')] += 1 
  }

  for k,v := range smap {
    if tmap[k] != v {
      return false
    }
  }
  return true
}
```


## 解法三

用 counter 遍历第一个字符串，记录字符出现次数。第二次遍历对应减少 counter 字符的值。  
如果减之前就为零，则说明不是异位词

```go
func isAnagram(s string, t string) bool {

  if len(s) != len(t) {
    return false
  }

  counter := make(map[int]int)
  for _, c := range s {
    counter[int(c - 'a')]++
  }

  for _, c:= range t {
    if counter[int(c - 'a')] == 0 {
      return false
    }
    counter[int(c - 'a')]--
  }

  return true
}
```

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:

        if len(s) != len(t):
            return False

        counter = dict()
        for c in s:
            if c not in counter: 
                counter[c] = 0
            counter[c] += 1
        
        for c in t:
            if c not in counter:
                return False
            counter[c] -= 1
            if counter[c] < 0:
                return False
        return True
          
```

```Java
class Solution {
    public boolean isAnagram(String s, String t) {
        
        if (s.length() != t.length()) return false;

        Map<Character, Integer> chs = new HashMap<>();

        for (int i = 0; i < s.length(); i++) {
            Character ch = s.charAt(i);
            if (chs.containsKey(ch)) {
                chs.put(ch, chs.get(ch) + 1);
            } else {
                chs.put(ch, 1);
            }
        }

        for (int i = 0; i < t.length(); i++) {
            Character ch = t.charAt(i);
            if (!chs.containsKey(ch)) return false;
            chs.put(ch, chs.get(ch) - 1);
            Integer count = chs.get(ch);
            if (count < 0) return false;
        }
        return true;
    }
}
```