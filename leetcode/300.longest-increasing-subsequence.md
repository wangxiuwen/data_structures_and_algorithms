# [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给定一个无序的整数数组, 找到其中最长上升子序列的长度。

示例:

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101], 它的长度是 4。
```

说明:

可能会有多种最长上升子序列的组合, 你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?


## 思路

1. 暴力 O(2^n)     
2. DP 复杂度 O(n^2)  

- a. DP[i] 从第一个元素开始, 到 第 i 个元素(包含第 i 个)的最长上升子序列  
    结果为 max(dp[0], dp[1], ... ,dp[n-1])
- b. 伪代码

```python
for i: 0-> n-1:
    dp[i] = max(dp[j] + 1) # j: 0->i-1 且 a[j] < a[i], 等价于 dp[i] = max(dp[j]) + 1
```

3. 二分法 O(NlogN)

- a. 维护数组 LIS, 最终结果为 LIS 数组的长度
- b. 伪代码

```python
for i: 0 -> n-1:
    IIS 为空或者第 i 个元素 比 LIS 数组中所有元素都大, 则append 到数组末尾  
    否则(用二分法查找)替换 LIS 数组中比 第 i 个元素大的数中的最小的数
```

