# 51. n 皇后

n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

![](./51/8-queens.png)

上图为 8 皇后问题的一种解法。

给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。

每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

示例:

输入: 4
输出: [
 [".Q..",  // 解法 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解法 2
  "Q...",
  "...Q",
  ".Q.."]
]
解释: 4 皇后问题存在两个不同的解法。


## 思路

用四皇后来验证

## 解法一

回溯

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
      if n < 1:
        return []
      
      self.result = []
      self.cols = set()
      self.pie = set()
      self.na = set()
      self.dfs(n, 0, [])
      return self._generate_result(n)
      
    def dfs(self, n, row, cur_state):
      # terminator
      if row >= n:
        self.result.append(cur_state)
        return
      
      # process
      for col in range(n):
        if col in self.cols or row + col in self.pie or row - col in self.na:
          continue

        self.cols.add(col)
        self.pie.add(row + col)
        self.na.add(row - col)
        
        self.dfs(n, row + 1, cur_state + [col])

        self.cols.remove(col)
        self.pie.remove(row + col)
        self.na.remove(row - col)
    
    def _generate_result(self, n):
      board = []
      for res in self.result:
        for i in res:
          board.append('.' * i + 'Q' + '.' * (n - i - 1))
      
      return [board[i: i + n] for i in range(0, len(board), n)]
```

简洁的解法

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
      self.result = []
      self.dfs(n, [], [], [])
      return [ ['.' * i + 'Q' + '.' * (n-i-1) for i in sol] for sol in self.result]
    
    def dfs(self, n, queens, xy_diff, xy_sum):
      length = len(queens)
      if length == n:
        self.result.append(queens)
        return
      
      for col in range(n):
        if col not in queens and length - col not in xy_diff and length + col not in xy_sum:
          self.dfs(n, queens + [col], xy_diff + [length - col], xy_sum + [length + col])
```

## 解法二


```python
def totalNQueens(self, n): 
  if n < 1: return [] 
  self.count = 0 
  self.DFS(n, 0, 0, 0, 0) 
  return self.count

def DFS(self, n, row, cols, pie, na): # recursion terminator
  if row >= n:
    self.count += 1 
    return
  
  bits=(~(cols|pie|na))&((1<<n)—1) # 得到当前所有的空位 
  
  while bits:
    p = bits & —bits # 取到最低位的1
    bits = bits & (bits — 1) # 表示在p位置上放入皇后
    self.DFS(n, row + 1, cols | p, (pie | p) << 1, (na | p) >> 1)
    # 不需要revert cols, pie, na 的状态
```

```Java
class Solution {
    private int size;
    private int count;

    private void solve(int row, int ld, int rd) {
        if (row == size) {
            count++;
            return;
        }
        int pos = size & (~(row | ld | rd));
        while (pos != 0) {
            int p = pos & (-pos);
            pos -= p; // pos &= pos - 1;
            solve(row | p, (ld | p) << 1, (rd | p) >> 1);
        }
    }

    public int totalNQueens(int n) {
        count = 0;
        size = (1 << n) - 1;
        solve(0, 0, 0);
        return count;
    }
}
```


## 其它解法

# Python

```python
def totalNQueens(self, n): 
	if n < 1: return [] 
	self.count = 0 
	self.DFS(n, 0, 0, 0, 0) 
	return self.count

def DFS(self, n, row, cols, pie, na): 
	# recursion terminator 
	if row >= n: 
		self.count += 1 
		return

	bits = (~(cols | pie | na)) & ((1 << n) — 1)  # 得到当前所有的空位

	while bits: 
		p = bits & —bits # 取到最低位的1
		bits = bits & (bits — 1) # 表示在p位置上放入皇后
		self.DFS(n, row + 1, cols | p, (pie | p) << 1, (na | p) >> 1) 
        # 不需要revert  cols, pie, na 的状态
```


```Java
class Solution {
	private int size; 
	private int count;

	private void solve(int row, int ld, int rd) { 
		if (row == size) { 
			count++; 
			return; 
		}
		int pos = size & (~(row | ld | rd)); 
		while (pos != 0) { 
			int p = pos & (-pos); 
			pos -= p; // pos &= pos - 1; 
			solve(row | p, (ld | p) << 1, (rd | p) >> 1); 
		} 
	} 

public int totalNQueens(int n) { 
	count = 0; 
	size = (1 << n) - 1; 
	solve(0, 0, 0); 
	return count; 
  } 
}
```


```python
# 附带非位运算判重（Python）
def solveNQueens(self, n):
  def DFS(queens, xy_dif, xy_sum):
    p = len(queens)
    if p==n:
        result.append(queens)
        return None
    for q in range(n):
        if q not in queens and p-q not in xy_dif and \
          p+q not in xy_sum: 
            DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q])  
  result = []
  DFS([],[],[])
  return [ ["."*i + "Q" + "."*(n-i-1) for i in sol] for sol in result]
```


```C++
class Solution {
public:
    int totalNQueens(int n) {
        dfs(n, 0, 0, 0, 0);
        
        return this->res;
    }
    
    void dfs(int n, int row, int col, int ld, int rd) {
        if (row >= n) { res++; return; }
        
        // 将所有能放置 Q 的位置由 0 变成 1，以便进行后续的位遍历
        int bits = ~(col | ld | rd) & ((1 << n) - 1);
        while (bits > 0) {
            int pick = bits & -bits; // 注: x & -x
            dfs(n, row + 1, col | pick, (ld | pick) << 1, (rd | pick) >> 1);
            bits &= bits - 1; // 注: x & (x - 1)
        }
    }


private:
    int res = 0;
};
```

[C++ 题解](https://leetcode.com/problems/n-queens/discuss/19808/Accepted-4ms-c++-solution-use-backtracking-and-bitmask-easy-understand)  

```C++
class Solution {
public:
    std::vector<std::vector<std::string> > solveNQueens(int n) {
        std::vector<std::vector<std::string> > res;
        std::vector<std::string> nQueens(n, std::string(n, '.'));
        solveNQueens(res, nQueens, 0, n);
        return res;
    }
private:
    void solveNQueens(std::vector<std::vector<std::string> > &res, std::vector<std::string> &nQueens, int row, int &n) {
        if (row == n) {
            res.push_back(nQueens);
            return;
        }
        for (int col = 0; col != n; ++col)
            if (isValid(nQueens, row, col, n)) {
                nQueens[row][col] = 'Q';
                solveNQueens(res, nQueens, row + 1, n);
                nQueens[row][col] = '.';
            }
    }

    // 这里傻算不如直接用数组存储
    bool isValid(std::vector<std::string> &nQueens, int row, int col, int &n) {
        //check if the column had a queen before.
        for (int i = 0; i != row; ++i)
            if (nQueens[i][col] == 'Q')
                return false;
        //check if the 45° diagonal had a queen before.
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j)
            if (nQueens[i][j] == 'Q')
                return false;
        //check if the 135° diagonal had a queen before.
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; --i, ++j)
            if (nQueens[i][j] == 'Q')
                return false;
        return true;
    }
};
```