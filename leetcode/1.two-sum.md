# 两数之和

[题目来源](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:

```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

## 思路

判断一个数在集合内是否存在，要用到数据结构 Set 或者 哈希表

Python 2.3. 以上版本可用 enumerate ，2.6 添加 start 参数 :

```python
enumerate(sequence, [start=0])
```

```python
seq = ['one', 'two', 'three']
for i, element in enumerate(seq):
    print(i, element)
```

## 解法一

暴力求解

```Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length-1; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                int sum = nums[i] + nums[j]; 
                if (sum == target) return new int[]{i, j};
            }
        }
        return new int[]{};
    }
}
```


## 解法二


```Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> m = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
           m.put(nums[i], i); 
        }
        for (int i = 0; i < nums.length; i++) {
            int another = target - nums[i];
            if (m.containsKey(another) && m.get(another) != i) return new int[]{i, m.get(another)};
        }
        return new int[]{};
    }
}
```

```python
class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        m = {}
        res = []
        for i in range(len(nums)):
            m[nums[i]] = i
        for i in range(len(nums)):
            t = target - nums[i]
            if t in m and m[t] != i:
                res.append(i)
                res.append(m[t])
                break
            
        return res


```

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> m;
        vector<int> res;
        for (int i = 0; i < nums.size(); ++i) {
            m[nums[i]] = i;
        }
        for (int i = 0; i < nums.size(); ++i) {
            int t = target - nums[i];
            if (m.count(t) && m[t] != i) {
                res.push_back(i);
                res.push_back(m[t]);
                break;
            }
        }
        return res;
    }
};


int main() 
{
    Solution *solution = new Solution();
    vector<int> nums = {2, 7, 11, 15};
    vector<int> result = solution->twoSum(nums, 9);
    for(int i=0; i<result.size(); ++i)
        std::cout << result[i] << ' ';
    return 0;
}
```

## 解法三

减少一次循环

```Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        
        Map<Integer, Integer> m = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
            int x = target - nums[i];
            if (m.containsKey(x) && m.get(x) != i) {
                return new int[]{i, m.get(x)};
            } else m.put(nums[i], i);
        }
        return new int[]{};
    }
}
```

```python
class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        m = {}
        res = []
        for i in range(len(nums)):
            t = target - nums[i]
            if t in m:
                res.append(m[t])
                res.append(i)
                break
            m[nums[i]] = i
        return res
```
