# 链表

- 单链表

![](./linked_list/1.jpg)

>每个节点只包含一个指针，即后继指针
头节点指向整条链表，尾节点的后继指针指向空地址 null
插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)

- 双向链表

![](./linked_list/2.jpg)

>节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）
头节点的前驱指针prev和尾节点的后继指针均指向空地址

- 循环链表

![](./linked_list/3.jpg)

>除了尾节点的后继指针指向头节点的地址外均与单链表一致。
适用于存储有循环特点的数据，比如 [约瑟夫斯问题](https://zh.wikipedia.org/wiki/约瑟夫斯问题)

- 双向循环链表

![](./linked_list/4.jpg)

>头节点的前驱指针指向尾节点，尾节点的后继指针指向头节点

## 链表的时间复杂度

|  操作   | 复杂度  |
|  ----  | ----  |
|  space  | O(n) |
|  查找 lookup  | O(n) |
|  插入 insert prepend | O(1) |
|  插入 insert append | O(1) |
|  删除 delete | O(1) |

## 数组和链表的对比

| 时间复杂度 | 数组  | 链表 ｜
| ---- | ----  | ----  |
| 插入删除 | O(n) | O(1) |
| 随机访问 | O(1) | O(n) |

>插入删除较多，用链表
数组在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，访问效率更高
链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读

## Java 中的 双向链表：

  LinkedHashMap

## 缓存淘汰策略

- 先进先出策略FIFO（First In，First Out）
- 最少使用策略LFU（Least Frequently Used）
- 最近最少使用策略LRU（Least Recently Used）


