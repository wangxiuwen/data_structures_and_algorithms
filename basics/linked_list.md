# 链表

- 单链表

![](./linked_list/1.jpg)

>每个节点只包含一个指针，即后继指针  
头节点指向整条链表，尾节点的后继指针指向空地址 null  
插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)  

- 双向链表

![](./linked_list/2.jpg)

>节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）  
头节点的前驱指针prev和尾节点的后继指针均指向空地址

- 循环链表

![](./linked_list/3.jpg)

>除了尾节点的后继指针指向头节点的地址外均与单链表一致。
适用于存储有循环特点的数据，比如 [约瑟夫斯问题](https://zh.wikipedia.org/wiki/约瑟夫斯问题)

- 双向循环链表

![](./linked_list/4.jpg)

>头节点的前驱指针指向尾节点，尾节点的后继指针指向头节点

## 链表的时间复杂度

|  操作   | 复杂度 |
|  ----  | ---- |
|  space  | O(n) |
|  查找 lookup  | O(n) |
|  插入 insert prepend | O(1) |
|  插入 insert append | O(1) |
|  删除 delete | O(1) |

## 数组和链表的对比

| 时间复杂度 | 数组 | 链表 ｜
| ---- | ---- | ---- |
| 插入删除 | O(n) | O(1) |
| 随机访问 | O(1) | O(n) |

>插入删除较多，用链表  
数组在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，访问效率更高  
链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读  

## Java 中的 双向链表：

  LinkedHashMap

## 缓存淘汰策略

- 先进先出策略FIFO（First In，First Out）
- 最少使用策略LFU（Least Frequently Used）
- 最近最少使用策略LRU（Least Recently Used）


## 基于链表实现LRU缓存淘汰算法

我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

>1.如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。  
2.如果此数据没有在缓存链表中，又可以分为两种情况：  
如果此时缓存未满，则将此结点直接插入到链表的头部；  
如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。  
这样我们就用链表实现了一个LRU缓存  